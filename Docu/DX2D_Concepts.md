# 물방울책 4장. Direct3D의 초기화
<br>

p.102

## 1. 기본지식
<br>

### 1. Direct3D 개요

DirectX3D : 응용 프로그램이 3차원 그래픽 가속 기능을 이용하여 3차원 세계를 렌더링할 수 있게 해주는 저수준 API
- DirectX : (하드웨어에) Direct(직접적으로) eXcess(접근한다)
- API : Application Programming Interface

그래픽 하드웨어를 제어할 수 있는 소프트웨어 인터페이스 제공.
- 하드웨어의 세부사항을 고려할 필요 없이, 주어진 인터페이스를 이용하여 제어할 수 있게 해줌.


<br>

### 2. COM

COM : DirectX의 프로그래밍 언어 독립성과 하위 호환성을 가능하게 하는 기술
- COM : Component Object Model

COM 객체들은 개발환경 보다 더 깊은(?) 단계에서 자신만의 고유한 방식으로 메모리를 관리함.
- 개발에 필요한 COM 인터페이스로의 포인터는<br> 특별한 함수 혹은 다른 COM 인터페이스의 method를 이용하여 할당(참조).
- COM의 super class인 `IUnknown` 객체의 Release 메서드를 이용하여 해제.
- (+) COM 인터페이스은 식별자가 `I` 로 시작한다

<br>

### 3. 텍스처 및 자료 자원 형식

2차원 텍스처는 사실상 자료 원소들의 행렬(2차원 배열).
- 2차원 텍스처는 여러 용도로 사용된다.
	1. 2차원 이미지 저장용도 : 해당 픽셀의 색상이 행렬에 할당
	2. 법선 매핑 : 해당 픽셀에서의 3차원 벡터를 행렬에 할당
	- "텍스처"라고 하면 이미지 저장을 떠올리지만, 실제로는 매우 범용적으로 사용됨.

텍스처는 여러가지 용도로 사용 가능하다보니, 단순 자료 배열 이상으로 사용되기도 한다.
- GPU 필터링, 다중 표본화 등 특별한 연산을 텍스처에 적용할 수 있음.
- 때문에 텍스처의 각 texel에는 약속된 형식을 따르는 자료(format)만 담을 수 있으며, 이는 `DXGI_FORMAT`이라는 열거형(enum)으로 지정.
	- texel : texture element
- (예시)
```Cpp
1. DXGI_FORMAT_R32G32B32_FLOAT
	각 원소는 32비트 부동 소수점 element 3개로 이루어짐
	- 3차원 벡터 정보를 담는데 탁월

2. DXGI_FORMAT_R16G16B16A16_UNORM
	각 원소는 [0,1] 구간 16비트 element 4개로 이루어짐

3. DXGI_FORMAT_R32G32_UINT
	각 원소는 32비트 부호 없는 정수 element 2개로 이루어짐

4. DXGI_FORMAT_R8G8B8A8_UNORM
	각 원소는 [0,1] 구간 8비트 element 4개로 이루어짐

5. DXGI_FORMAT_R8G8B8A8_SNORM
	각 원소는 [-1,1] 구간 8비트 element 4개로 이루어짐

6. DXGI_FORMAT_R8G8B8A8_SINT
	각 원소는 8비트의 부호 있는 정수 element 4개로 이루어짐

7. DXGI_FORMAT_R8G8B8A8_UINT
	각 원소는 8비트의 부호 없는 정수 element 4개로 이루어짐.

8. DXGI_FORMAT_R8G8B8A8_TYPELESS
	각 원소에 8비트의 성분 4개를 할당하지만, 그 형식은 지정치 않는다.
	- 메모리만 확보 후 자료의 구체적인 해석 방식은 추후 텍스처를 파이프라인에 묶을 때 지정.
```
- (+) NORM : Normalized thing (정규화) -> 절대값이 0 이상 1 이하인 수
- (+) R G B A : Red / Green / Blue / Alpha(투명도)
 
 <br>

### 4. 교환 사슬과 페이지 전환

- 교환 사슬 : Swap Chain

매(per) Frame 마다 화면에 바로바로 출력하면, 이용자들의 눈에 화면이 깜빡이면서 결과물이 출력됨.<br>
이를 해결하기 위해 나온 방법.

1. 모니터에 표시될 이미지 자료를 담고 있는 텍스처를 전면 버퍼(Front Buffer)라 한다.
2. 화면 바깥의 텍스처를 후면 버퍼(Back Buffer)라 하고, 여기에 애니메이션 한 프레임 전체를 그린다.
	- 사용자의 눈에는 프레임이 그려지는 과정이 나타나지 않음.
3. 전면 버퍼와 후면 버퍼의 역할을 바꾼다.
4. 현재의 전면 버퍼('2'의 후면버퍼)를 하나의 완전한 프레임으로서 화면에 출력한다.
5. '1'의 과정부터 반복한다.

위의 '3', '4' 과정을 <b>제시</b>(presenting) 라 함.<br>
전면 버퍼로의 포인터와 후면 버퍼로의 포인터만 맞바꾸기(Swap)에 효율적인 연산.
- `IDXGISwapChain` 이라는 인터페이스로 사용 가능.
- 이 처럼 두 개의 버퍼를 이용하는 것을 <b>이중 버퍼링</b>(double buffering) 이라 함.

<br>

### 5. 깊이 버퍼링

- 깊이 버퍼 : Depth Buffer

깊이 버퍼는 이미지 자료를 담지 않는 한 예.<br>
각 texel에 깊이 정보를 담고있는 버퍼.
- texel의 깊이 구간은 [0.0, 1.0]이고,	 <br>
0.0 은 관찰자와 최대한 가까운 texel, 1.0 은 최대한 먼 texel.
- 깊이 버퍼와 후면 버퍼의 픽셀들은 1:1 대응.
- 한 물체의 픽셀들이 다른 물체보다 앞에 있는지 판정하기 위해 "깊이 버퍼링" 또는 "Z-버퍼링"을 사용.
- 깊이 버퍼 또한 하나의 텍스처로서, 각 texel에는 약속된 자료 형식(format)만 담을 수 있다.
- (예시)
```Cpp
1. DXGI_FORMAT_D32_FLOAT_S8X24_UINT
	각 텍셀은 깊이 값(32 비트 부동 소수점), 스텐실 값(스텐실 버퍼에 사용(?))(8비트 부호 없는 정수),
	그리고 다른 용도 없이 채움(padding)용으로 쓰이는 값(24비트)으로 구성

2. DXGI_FORMAT_D32_FLOAT
	각 텍셀은 깊이 값(32 비트 부동 소수점) element 1개로 이루어짐

3. DXGI_FORMAT_D24_UNORM_S8_UINT
	각 텍셀은 깊이 값([0,1] 구간 24비트)과 스텐실 값(8비트 부호없는 정수)인 element 2개로 이루어짐

4. DXGI_FORMAT_D16_UNORM
	각 텍셀은 깊이 값([0,1] 구간의 16비트) element 1개로 이루어짐
```


#### 이해

- 결국 화면 출력 공간은 2차원 공간이기 때문에, 2차원 배열의 한정된 자원에 중첩되어 해당 element를 차지하려 한다.

코드의 순서대로 물체들이 후면 버퍼에 갱신될 것이고, 하나의 픽셀을 2개 이상의 텍스처가 경쟁하는 상황이 생긴다.<br>
이 때 해당 픽셀을 갱신하려는 텍스처의 깊이 버퍼를 관찰하여 <br>
크기가 작으면 (더 가까우면) 후면 버퍼의 해당 픽셀 정보에 새로운 텍스처의 정보를 덧씌우고,<br>
또한 새로운 텍스처의 깊이를 후면 퍼버의 깊이 버퍼에 갱신한다. <br>
만약 크기가 크면 (더 멀다면) 후면 버퍼의 어떠한 값도 갱신치 않고 지나간다.

<br>

### 6. 텍스처 자원 뷰

"렌더링 파이프라인" 에는 텍스처를 묶을(bind) 수 있는 단계(stage)들이 여럿 존재.
	- (예시)텍스처를 렌더 대상으로 묶는 것.
	- (예시)셰이더를 자원으로서 묶는 것.

(추가 필기 필요)

<br>

### 7. 다중 표준화 이론

모니터의 픽셀들이 무한히 작지는 않기 때문에, 모니터의 화면에 임의의 선을 완벽히 나타내는 것은 불가능함
- 선을 픽셀들의 배열로 근사할 때 각지게 생성되는 것을 "계단 현상"(<b>앨리어싱</b>_aliasing)이라 함.

위의 상황을 해결하기 위해 <b>앨리어싱 제거</b>(anti-aliasing) 기법들이 존재.
- 초과 표본화 : super sampling
	- 후면 버퍼와 깊이 버퍼의 크기를 화면 해상도 보다 4배 크게 잡고, <br>
	이미지를 제시할 때 후면 버퍼를 원래 크기의 버퍼로 환원(resolving) 하여 그 간극을 좁히는 것.
	- 사용해야 하는 자원이 많아진다.

(추가 필기 필요)

<br>

### 8. Direct3D의 다중 표본화

(추가 필기 필요?) (개념만 가져갈거면 X)

<br>

### 9. 기능 수준

- 기능 수준 : feature level

하위 버전과의 호환성을 위해 기능성 집합을 정의함.
- 만약 사용자의 하드웨어가 특정 기능 수준을 지원하지 않으면 더 낮은 기능 수준으로 내려가 응용 프로그램을 실행한다는 것.
 
(추가 필기 필요?) (개념만 가져갈거면 X)

<br>
